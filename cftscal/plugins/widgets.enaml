import shutil

import numpy as np
from palettable.tableau import Tableau_20
import pyqtgraph as pg

from atom.api import Atom, Bool, Dict, Float, List, Tuple, Typed, Value
import enaml
with enaml.imports():
    from psi.data.plots_manifest import PGCanvas

from enaml.colors import Color
from enaml.core.api import DynamicTemplate, Looper
from enaml.layout.api import (
    align, hbox, spacer, vbox, AreaLayout, HSplitLayout, VSplitLayout, TabLayout
)
from enaml.stdlib.fields import FloatField, RegexField
from enaml.stdlib.message_box import question
from enaml.qt import QtCore
from enaml.widgets.api import (
    Action, ActionGroup, Container, Label, Field, Form, MainWindow, Menu, MenuBar,
    ObjectCombo, PopupView, PushButton, DockArea, DockItem,
)
from enamlx.widgets.api import TreeView, TreeViewItem, TreeViewColumn

from psi.data.plots import make_color
from psiaudio import util
from cftscal.objects import (
    CFTSInEarCalibration, CFTSInputAmplifierCalibration,
    CFTSMicrophoneCalibration, CFTSStarshipCalibration, CFTSSpeakerCalibration,
)


enamldef AddItem(PopupView): popup:

    attr combo
    window_type = 'popup'
    arrow_size = 20
    arrow_edge = 'top'
    alias label: label.text
    alias regex: field.regex

    Container:
        constraints = [
            vbox(
                hbox(label, field),
                hbox(spacer(0), pb_ok, pb_cancel, spacing=0)
            ),
            align('v_center', label, field),
            align('v_center', pb_ok, pb_cancel),
            align('width', pb_ok, pb_cancel),
        ]

        Label: label:
            pass
        RegexField: field:
            regex = f'^[\w\d-]+$'
        PushButton: pb_ok:
            text = 'OK'
            enabled << bool(field.text)
            clicked ::
                items = combo.items[:]
                items.append(field.text)
                combo.items = items
                combo.selected = field.text
                popup.close()

        PushButton: pb_cancel:
            text = 'Cancel'
            clicked ::
                popup.close()


class BasePlotManager(Atom):

    component = Typed(pg.GraphicsLayout)
    color_cycle = Value()
    plots = Dict()

    def _default_color_cycle(self):
        return iter(Tableau_20.colors)

    def _default_component(self):
        raise NotImplementedError

    def _default_plots(self):
        return {}

    def create_plot(self, color=None, width=2, line='solid'):
        if color is None:
            try:
                color = make_color(next(self.color_cycle))
            except StopIteration:
                # We have exhausted the color cycle. Just start over again at
                # the beginning.
                self.color_cycle = self._default_color_cycle()
                color = make_color(next(self.color_cycle))
        else:
            # Coerce color back to Qcolor for use by pygtgraph
            color = make_color(color)

        linestyle = getattr(QtCore.Qt.PenStyle, f'{line.capitalize()}Line')
        pen = pg.mkPen(color, width=width, style=linestyle)
        return color, pg.PlotCurveItem(pen=pen)

    def create_empty_plots(self, color=None, width=2, line='solid'):
        color, plot = self.create_plot(color=color, width=width, line=line)
        return color, [plot]

    def get_plots(self, plot_id, vb, **kw):
        if plot_id not in self.plots:
            color, plots = self.create_empty_plots(**kw)
            # Convert to Enaml color for highlight in object tree 
            color = Color(color.red(), color.green(), color.blue(),
                          color.alpha())
            self.plots[vb, plot_id] = color, plots
            for plot in plots:
                vb.addItem(plot)
        return self.plots[vb, plot_id]

    def notify(self, item, selected):
        if selected:
            return self._update(item, remove=False)
        else:
            return self._update(item, remove=True)

    def remove_plots(self, plot_id, vb):
        _, plots = self.plots.pop((vb, plot_id), (None, []))
        for plot in plots:
            vb.removeItem(plot)


class SinglePlotManager(BasePlotManager):

    vb = Typed(pg.ViewBox)
    legend = Typed(pg.LegendItem)

    def _default_legend(self):
        legend = pg.LegendItem()
        legend.setParentItem(self.vb)
        return legend

    def _default_vb(self):
        vb = pg.ViewBox()
        vb.setBackgroundColor('w')
        return vb

    def _default_component(self):
        component = pg.GraphicsLayout()
        component.setSpacing(10)
        y_axis = self.make_y_axis()
        x_axis = self.make_x_axis()
        component.addItem(y_axis, 0, 0)
        component.addItem(x_axis, 1, 1)

        y_axis.linkToView(self.vb)
        x_axis.linkToView(self.vb)
        component.addItem(self.vb, 0, 1)

        return component

    def make_y_axis(self):
        y_axis = pg.AxisItem('left')
        y_axis.setLabel('Sensitivity (dB re 1Vrms)')
        y_axis.setGrid(64)
        return y_axis

    def make_x_axis(self):
        x_axis = pg.AxisItem('bottom')
        x_axis.setGrid(64)
        x_axis.setLabel('Frequency', units='Hz')
        x_axis.setLogMode(True)
        return x_axis

    def get_plot_id(self, item):
        return item

    def _update(self, item, remove=False):
        if remove:
            self.remove_plots(item, self.vb)
            return None
        color, plots = self.get_plots(item, self.vb)
        self._plot(item, plots[0])
        return {'color': color}

    def _plot(self, item, plot):
        raise NotImplementedError


class TimePSDPlotManager(BasePlotManager):

    region_select = Value()
    time_vb = Value()
    psd_vb = Value()
    data = Value()

    apply_calibration = Bool(True)

    _selecting = Bool(False)
    _initial_x = Value()

    def _default_component(self):
        component = pg.GraphicsLayout()
        component.setSpacing(10)

        # Set up time series viewbox
        x_axis = pg.AxisItem('bottom')
        x_axis.setGrid(64)
        x_axis.setLabel('Time', units='s')
        y_axis = pg.AxisItem('left')
        if self.apply_calibration:
            y_axis.setLabel('Signal (Pa)')
        else:
            y_axis.setLabel('Signal (V)')
        y_axis.setGrid(64)
        self.time_vb = vb = pg.ViewBox()
        vb.setBackgroundColor('w')
        y_axis.linkToView(vb)
        x_axis.linkToView(vb)
        component.addItem(y_axis, 0, 0)
        component.addItem(x_axis, 1, 1)
        component.addItem(vb, 0, 1)

        # Set up time series viewbox
        x_axis = pg.AxisItem('bottom')
        x_axis.setGrid(64)
        x_axis.setLabel('Frequency', units='Hz')
        y_axis = pg.AxisItem('left')
        y_axis.setGrid(64)
        if self.apply_calibration:
            y_axis.setLabel('PSD (dB SPL)')
        else:
            y_axis.setLabel('PSD (dB re 1 Vrms)')

        self.psd_vb = vb = pg.ViewBox()
        vb.setBackgroundColor('w')
        y_axis.linkToView(vb)
        x_axis.linkToView(vb)
        component.addItem(y_axis, 2, 0)
        component.addItem(x_axis, 3, 1)
        component.addItem(vb, 2, 1)

        self.data = {}

        return component

    def _mouse_click(self, event):
        if self.time_vb.sceneBoundingRect().contains(event.scenePos()):
            point = self.time_vb.mapSceneToView(event.scenePos())
            if not self._selecting:
                new_region = (point.x(), point.x())
                self._selecting = True
                self._initial_x = point.x()
            else:
                region = self.region_select.getRegion()

                new_region = (self._initial_x, point.x())
                self._selecting = False
            region = self.region_select.setRegion(new_region)

    def _mouse_move(self, pos):
        return
        if self.time_vb.sceneBoundingRect().contains(pos):
            point = self.time_vb.mapSceneToView(pos)
            if not self._selecting:
                return
            region = self.region_select.getRegion()
            new_region = (self._initial_x, point.x())
            region = self.region_select.setRegion(new_region)

    def _region_select_updated(self):
        # Don't update PSD until region select complete
        if self._selecting:
            print('skipping')
            return
        xlb, xub = self.region_select.getRegion()
        for d in self.data.values():
            x, y, fs, cal = d['x'], d['y'], d['fs'], d['calibration']
            m = (x >= xlb) & (x < xub)
            if m.any():
                psd = cal.get_db(util.psd_df(y[m], fs=fs))
                d['psd_plot'][0].setData(np.log10(psd.index.values), psd.values)
                ptp = np.ptp(y[m])
            else:
                d['psd_plot'][0].setData([], [])

    def remove(self, recording):
        self._update(recording, True)

    def _update(self, item, remove=False):
        if remove:
            self.remove_plots(item, self.time_vb)
            self.remove_plots(item, self.psd_vb)
            return

        if self.region_select is None:
            def click(event):
                nonlocal self
                self._mouse_click(event)
            def move(pos):
                nonlocal self
                self._mouse_move(pos)
            self.time_vb.scene().sigMouseClicked.connect(click)
            self.time_vb.scene().sigMouseMoved.connect(move)

            def update():
                nonlocal self
                self._region_select_updated()

            self.region_select = region = pg.LinearRegionItem(values=(0, 0), movable=False)
            region.setZValue(10)
            region.sigRegionChanged.connect(update)
            self.time_vb.addItem(region, ignoreBounds=True)

        color, time_plot = self.get_plots(item, self.time_vb)
        _, psd_plot = self.get_plots(item, self.psd_vb)
        self.data[item] = self._plot(item, time_plot, psd_plot)
        self._region_select_updated()
        return {'color': color}

    def _plot(self, item, time_plot, psd_plot):
        fh = item.load_recording()
        epochs = fh.hw_ai.get_epochs(fh.epoch_metadata, offset=0,
                                     duration=fh.get_setting('duration'))
        y = epochs.mean(axis=0)
        if self.apply_calibration:
            cal = fh.hw_ai.get_calibration()
        else:
            cal = FlatCalibration.unity()
        y_cal = cal.get_level(y)
        time_plot[0].setData(y.index.values, y_cal.values)
        return {
            'x': y.index.values,
            'y': y.values,
            'fs': fh.hw_ai.fs,
            'calibration': cal,
            'time_plot': time_plot,
            'psd_plot': psd_plot,
        }


################################################################################
# Organize list of calibrated objects and calibrations for each object
################################################################################
class MultiPlotManager(Atom):
    '''
    Allow multiple plot managers to receive notifications
    '''
    managers = Tuple()

    def __init__(self, *managers):
        super().__init__(managers=managers)

    def plot(self, calibration):
        results = []
        for manager in self.managers:
            result = manager.plot(calibration)
            results.append(result)
        return results[0]

    def remove(self, calibration):
        results = []
        for manager in self.managers:
            result = manager.remove(calibration)
            results.append(result)
        return results[0]


class ObjectNode(Atom):
    '''
    Represents a single recording or calibration in the tree hierarchy
    '''
    selected = Bool(False)
    item = Value()
    parent = Value()
    color = Value(None)

    def _observe_selected(self, event):
        if self.selected:
            self.parent.notify(self, selected=True)
        else:
            self.parent.notify(self, selected=False)


class ObjectGroup(Atom):
    '''
    Represents a group of recordings or calibration in the tree hierarchy
    '''
    selected = Bool(False)
    item = Value()
    parent = Value()
    color = Value(None)
    subitems = List(ObjectNode)

    #: Internal flag to prevent race conditions when selecting/unselecting
    #: items in tree. We have the option of checking the group (allowing
    #: us to plot the most recent recording/calibration) or unchecking the
    #: group, which will remove all recordings/calibrations under the group
    #: from the plot.
    _skip_autoselect = Bool(False)

    def __init__(self, item, parent):
        self.item = item
        self.parent = parent
        self.update_subitems()

    def notify(self, node, selected):
        self.parent.notify(node, selected)

    def update_subitems(self):
        objects = sorted(self.item.list_calibrations(), reverse=True)
        self.subitems = [ObjectNode(item=obj, parent=self) for obj in objects]

    def _observe_subitems(self, event):
        for i in self.subitems:
            i.observe('selected', self._check_selected)
            i.observe('color', self._check_color)

    def _check_selected(self, event):
        for i in self.subitems:
            if i.selected:
                self._skip_autoselect = True
                self.selected = True
                self._skip_autoselect = False
                return
        self.selected = False

    def _check_color(self, event):
        for i in self.subitems:
            if i.color is not None:
                self.color = i.color
                break
        else:
            self.color = None

    def _observe_selected(self, event):
        if self.selected:
            if not self._skip_autoselect:
                self.subitems[0].selected = True
        else:
            for i in self.subitems:
                i.selected = False


class ObjectCollection(Atom):
    '''
    Manages the list of recording/calibration groups
    '''
    groups = List(ObjectGroup)

    #: Manager that implements a `list_objects` method (e.g.,
    #: `starship_manager.list_objects()`) that is used to load the items that
    #: are shown in the tree.
    object_manager = Value()

    #: Managers that respond to group/node selections in the tree.
    view_managers = Value()

    def __init__(self, object_manager, view_managers):
        self.object_manager = object_manager
        self.view_managers = view_managers
        self.update_groups()

    def update_groups(self):
        objects = sorted(self.object_manager.list_objects())
        self.groups = [ObjectGroup(obj, self) for obj in objects]

    def notify(self, node, selected):
        for manager in self.view_managers:
            result = manager.notify(node.item, selected)
            if not selected:
                node.color = None
            elif result is not None and 'color' in result:
                node.color = result['color']


template CalibratedObjectTemplate(item, MemberType: CFTSMicrophoneCalibration):
    TreeViewColumn:
        text << f'{item.sens:.2f} mV/Pa'
    TreeViewColumn:
        text << f'{item.sens_db:.2f} dB(mV/Pa)'
    TreeViewColumn:
        text << item.pistonphone


template CalibratedObjectTemplate(item, MemberType: CFTSInEarCalibration):
    TreeViewColumn:
        text << item.ear


template CalibratedObjectTemplate(item, MemberType: CFTSStarshipCalibration):
    TreeViewColumn:
        text << item.microphone
    TreeViewColumn:
        text << item.coupler
    TreeViewColumn:
        text << item.stimulus


template CalibratedObjectTemplate(item, MemberType: CFTSSpeakerCalibration):
    TreeViewColumn:
        text << item.microphone
    TreeViewColumn:
        text << item.method


template CalibratedObjectTemplate(item, MemberType: CFTSInputAmplifierCalibration):
    TreeViewColumn:
        text << f'{item.measured_gain:.0f}'


template CalibratedObjectTemplate(item, MemberType):
    pass


enamldef CalibratedObjects(Container):
    alias headers: tree.horizontal_headers
    attr collection

    TreeView: tree:
        horizontal_headers << ['Name']
        resize_mode = 'resize_to_contents'
        horizontal_stretch = True
        items << collection.groups
        Looper:
            iterable << parent.items
            TreeViewItem: tree_group:
                attr group << loop_item
                text << loop_item.item.name
                items << loop_item.subitems
                checkable = True
                checked := loop_item.selected
                background << loop_item.color
                Looper:
                    iterable << parent.items
                    TreeViewItem: tree_node:
                        checkable = True
                        checked := loop_item.selected
                        text << str(loop_item.item.datetime)
                        background << loop_item.color
                        Menu:
                            Action:
                                text = 'Set as reference'
                            Action:
                                separator = True
                            Action:
                                text = 'Delete'
                                triggered ::
                                    name = f'{loop_item.item.datetime} from {loop_item.item.name}'
                                    q = f'Are you sure you want to delete {name}?'
                                    button = question(tree_node, '', q)
                                    if button.text == 'Yes':
                                        shutil.rmtree(loop_item.item.filename)
                                        collection.update_groups()
                        DynamicTemplate:
                            base = CalibratedObjectTemplate
                            args = (loop_item.item, type(loop_item.item))
