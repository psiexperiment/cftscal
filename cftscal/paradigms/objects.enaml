import logging
log = logging.getLogger(__name__)

import functools
import os

from enaml.core.api import Conditional
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.core.enaml.api import ExperimentManifest
from psi.context.api import BoolParameter, ContextRow, EnumParameter, Parameter
from psi.controller.api import (
    ContinuousInput, DecimateTo, ExperimentAction, IIRFilter, MUXOutput
)
from psi.paradigms.core.io_mixins import ChannelInput, ChannelInputManifest

from cftscal.objects import microphone_manager, starship_manager
from cftscal.util import list_microphone_connections, list_starship_connections


def initialize_microphone(name, event):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')

    input_name = os.environ[f'CFTS_MICROPHONE']
    item_microphone = context.get_item(f'{name}_microphone')
    item_microphone.set_value(input_name)
    item_microphone.editable = False

    gain = os.environ[f'CFTS_MICROPHONE_{input_name.upper()}_GAIN']
    item_gain = context.get_item(f'{name}_microphone_input_gain')
    item_gain.set_value(gain)
    item_gain.editable = False

    if (name := os.environ.get(f'CFTS_MICROPHONE_{input_name.upper()}', None)):
        channel = controller.get_channel(f'hw_ai::microphone_{input_name}')
        channel.calibration = microphone_manager.from_string(name).load()
    else:
        raise ValueError('FOO')


enamldef Microphone(ExperimentManifest): manifest:
    '''
    Defines a microphone. The IO manifest will be scanned for all channels that
    contain "microphone" in the name. The channels must follow the naming
    convention:

        * microphone_<name>

    Environment variables are also needed to configure the starship

    CFTS_MICROPHONE
        Indicates which microphone name to use.

    CFTS_MICROPHONE_<name>_GAIN
        Indicates the current gain setting on the mcirophone amplifier.

    CFTS_MICROPHONE_<name>
        A calibration string (provided by cftscal) that will load the correct
        calibration when passed to `starship_manager.from_string`.
    '''

    id = 'microphone'
    title = manifest.id.capitalize().replace('_', ' ')

    Extension:
        id = manifest.id + '.commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = manifest.id + '.initialize_microphone_settings'
            handler = functools.partial(initialize_microphone, manifest.name)

    Extension:
        id = manifest.id + '.actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'plugins_started'
            command = manifest.id + '.initialize_microphone_settings'

    Extension:
        id = manifest.id + '.io'
        point = 'psi.controller.io'

        ContinuousInput:
            name = f'{manifest.name}_microphone'
            source_name = 'hw_ai::' + getattr(C, f'{manifest.name}_microphone')
            source::
                channel.gain = getattr(C, f'{manifest.name}_microphone_input_gain')

    Extension:
        id = manifest.id + '.context'
        point = 'psi.context.items'

        ContextRow:
            fmt = [f'{manifest.title}', microphone, 'with', gain, 'dB gain']
            name = f'{manifest.name}_microphone_settings'
            group_name = 'hardware_settings'

            EnumParameter: microphone:
                name = f'{manifest.name}_microphone'
                label = f'{manifest.title}'
                choices = {k: f'"{v}"' for k, v in list_microphone_connections().items()}
                scope = 'experiment'

            Parameter: gain:
                name = f'{manifest.name}_microphone_input_gain'
                label = f'{manifest.title} input gain (dB)'
                dtype = 'float64'
                default = 40
                scope = 'experiment'


def initialize_starship(name, side, event):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')

    starship = os.environ[f'CFTS_{side.upper()}_STARSHIP']
    item_starship = context.get_item(f'{name}')
    item_starship.set_value(starship)
    item_starship.editable = False

    gain = os.environ[f'CFTS_STARSHIP_{starship.upper()}_GAIN']
    item_gain = context.get_item(f'{name}_input_gain')
    item_gain.set_value(gain)
    item_gain.editable = False

    if (name := os.environ.get(f'CFTS_STARSHIP_{starship.upper()}', None)):
        channel = controller.get_channel(f'hw_ai::starship_{starship.upper()}_microphone')
        channel.calibration = starship_manager.from_string(name).load()


enamldef Starship(ExperimentManifest): manifest:
    '''
    Defines a starship that consists of one probe tube microphone and two
    speakers. The IO manifest will be scanned for all channels that contain
    "starship" in the name. The channels must follow the naming convention:

        * starship_<name>_primary
        * starship_<name>_secondary
        * starship_<name>_microphone

    If any of these channels are missing, that starship will not be available
    for selection.

    Environment variables are also needed to configure the starship. Here,
    <side> is set as an attribute on the manifest and <name> is the name as
    identified in the IO manifest:

    CFTS_<side>_STARSHIP
        Indicates which starship name to use.

    CFTS_STARSHIP_<name>_GAIN
        Indicates the current gain setting on the mcirophone amplifier.

    CFTS_STARSHIP_<name>
        A calibration string (provided by cftscal) that will load the correct
        calibration when passed to `starship_manager.from_string`.

    Attributes that change the behavior of the plugin.

    output_mode: {'dual', 'select'}
        If 'dual', then both oututp speakers are made available as outputs
        named <id>_primary and <id>_secondary. If 'select', then a parameter is
        added to the GUI that allows the user to select between "primary" and
        "secondary" outputs and a single output named <id>_output is made
        available.

    side : string
        When initializing a starship from environment variables, you can
        differentiate between starships designed for certain purposes (e.g.,
        test vs. nontest).


    '''

    id = 'starship'
    title = manifest.id.capitalize().replace('_', ' ')
    attr output_mode = 'dual'
    attr side = 'test'

    Extension:
        id = manifest.id + '.commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = manifest.id + '.initialize_starship_settings'
            handler = functools.partial(initialize_starship, manifest.name, manifest.side)

    Extension:
        id = manifest.id + '.actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'plugins_started'
            command = manifest.id + '.initialize_starship_settings'

    Extension:
        id = manifest.id + '.io'
        point = 'psi.controller.io'

        ContinuousInput:
            name = f'{manifest.name}_microphone'
            source_name = 'hw_ai::' + getattr(C, f'{manifest.name}') + '_microphone'
            source::
                channel.gain = getattr(C, f'{manifest.name}_input_gain')

        Conditional:
            condition = manifest.output_mode == 'dual'

            MUXOutput:
                name = f'{manifest.name}_primary'
                target_name = 'hw_ao::' + getattr(C, f'{manifest.name}') + '_primary'

            MUXOutput:
                name = f'{manifest.name}_secondary'
                target_name = 'hw_ao::' + getattr(C, f'{manifest.name}') + '_secondary'

        Conditional:
            condition = manifest.output_mode == 'select'

            MUXOutput:
                name = f'{manifest.name}_output'
                target_name = 'hw_ao::' \
                    + getattr(C, f'{manifest.name}') + '_' \
                    + getattr(C, f'{manifest.name}_output')

    Conditional:
        condition << manifest.output_mode == 'select'

        Extension:
            id = manifest.id + '.context'
            point = 'psi.context.items'

            ContextRow:
                fmt = [f'{manifest.title}', starship, 'with', gain, 'dB gain'] \
                    if manifest.output_mode == 'dual' \
                    else [f'{manifest.title}', starship, 'with', gain, 'dB gain using', output, 'output']
                name = f'{manifest.name}_starship_settings'
                group_name = 'hardware_settings'

                EnumParameter: starship:
                    name = f'{manifest.name}'
                    label = f'{manifest.title}'
                    choices = {k: f'"{v}"' for k, v in list_starship_connections().items()}
                    scope = 'experiment'

                Parameter: gain:
                    name = f'{manifest.name}_input_gain'
                    label = f'{manifest.title} input gain (dB)'
                    dtype = 'float64'
                    default = 40
                    scope = 'experiment'

                EnumParameter: output:
                    name = f'{manifest.name}_output'
                    choices = {'primary': '"primary"', 'secondary': '"secondary"'}

    Conditional:
        condition << manifest.output_mode == 'dual'

        Extension:
            id = manifest.id + '.context'
            point = 'psi.context.items'

            ContextRow:
                fmt = [f'{manifest.title}', starship, 'with', gain, 'dB gain']
                name = f'{manifest.name}_starship_settings'
                group_name = 'hardware_settings'

                EnumParameter: starship:
                    name = f'{manifest.name}'
                    label = f'{manifest.title}'
                    choices = {k: f'"{v}"' for k, v in list_starship_connections().items()}
                    scope = 'experiment'

                Parameter: gain:
                    name = f'{manifest.name}_input_gain'
                    label = f'{manifest.title} input gain (dB)'
                    dtype = 'float64'
                    default = 40
                    scope = 'experiment'


enamldef InputAmplifierFilter(IIRFilter):
    N = 2
    btype = 'bandpass'
    ftype = 'butter'
    passthrough = not C.digital_filter
    f_highpass = C.digital_highpass
    f_lowpass = C.digital_lowpass


enamldef BaseAmplifierInput(ChannelInput):
    label = 'Amplifier'
    name = 'input_amplifier'
    show_gain_setting = False


enamldef AmplifierInput(BaseAmplifierInput): base:
    InputAmplifierFilter:
        name = f'{base.name}_filtered'


enamldef DecimatedAmplifierInput(BaseAmplifierInput): base:
    '''
    This makes it easier to use the InputAmplifierInput with various assays
    (e.g., ABR vs.  EFR) that require different filtering parameters.
    '''
    alias target_fs: dec.target_fs
    DecimateTo: dec:
        name = f'{base.name}_dec'
        InputAmplifierFilter:
            name = f'{base.name}_filtered'


enamldef BaseAmplifierInputManifest(ChannelInputManifest): manifest:

    Extension:
        id = manifest.id + '.input_amplifier.context'
        point = 'psi.context.items'

        ContextRow:
            fmt = ['Amplifier filter', hp, 'to', lp, 'Hz at', gain, '✕ gain']
            group_name = 'hardware_settings'

            Parameter: hp:
                name = 'amplifier_highpass'
                label = 'Amplifier highpass filter cutoff'
                default = 10
                scope = 'experiment'

            Parameter: lp:
                name = 'amplifier_lowpass'
                label = 'Amplifier lowpass filter cutoff'
                default = 10e3
                scope = 'experiment'
                group_name = 'hardware_settings'

            Parameter: gain:
                name = 'amplifier_gain'
                label = 'Amplifier gain'
                default = 100e3
                scope = 'experiment'
                group_name = 'hardware_settings'

        ContextRow:
            name = 'digital_filter_settings'
            fmt << ['Digital filter?', filt_on] \
                if filt_on.expression == 'False' else \
                ['Digital filter?', filt_on, 'from', filt_hp, 'to', filt_lp, 'Hz']
            group_name = 'acquisition'

            BoolParameter: filt_on:
                name = 'digital_filter'
                label = 'Digital filter?'
                scope = 'experiment'
                default = True

            Parameter: filt_hp:
                name = 'digital_highpass'
                label = 'Digital highpass filter cutoff'
                default = 300
                scope = 'experiment'

            Parameter: filt_lp:
                name = 'digital_lowpass'
                label = 'Digital lowpass filter cutoff'
                default = 3000
                scope = 'experiment'
